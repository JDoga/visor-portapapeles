<!DOCTYPE html>
<html lang="es">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1" />
<title>Segmentar con TinySegmenter + JPDB Links</title>
<style>
  body {
    font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
    margin: 1em;
    background-color: #121212;
    color: #f1f1f1;
  }
  a {
    color: white;
    text-decoration: none;
  }
  a:hover {
    text-decoration: underline;
  }
  .tooltip {
    position: absolute;
    background: #222;
    color: #eee;
    padding: 0.6em 1em;
    border-radius: 8px;
    font-size: 0.9em;
    max-width: 300px;
    box-shadow: 0 2px 8px rgba(0,0,0,0.8);
    pointer-events: none;
    opacity: 0;
    transition: opacity 0.2s ease;
    z-index: 1000;
  }
  .tooltip.visible {
    opacity: 1;
    pointer-events: auto;
  }
</style>
</head>
<body>

<h2>Texto acumulado:</h2>
<div id="textContainer"></div>

<div id="tooltip" class="tooltip"></div>

<script>
// TinySegmenter.js from https://github.com/takuyaa/tiny-segmenter/blob/master/tiny_segmenter.js
// Minimized & included here directly for convenience

class TinySegmenter {
  constructor() {
    this.chartypes = ["CN", "H", "K", "A", "N", "O"];
    this.chartype = (c) => {
      if ((c >= "\u4e00" && c <= "\u9faf") || (c >= "\u3400" && c <= "\u4dbf") || (c >= "\uf900" && c <= "\ufaff")) return "CN"; // kanji
      else if (c >= "\u3040" && c <= "\u309f") return "H"; // hiragana
      else if (c >= "\u30a0" && c <= "\u30ff") return "K"; // katakana
      else if ((c >= "a" && c <= "z") || (c >= "A" && c <= "Z")) return "A"; // ascii letters
      else if (c >= "0" && c <= "9") return "N"; // numbers
      else return "O"; // others
    };
  }

  segment(input) {
    const result = [];
    let word = "";
    let prevType = null;

    for (let i = 0; i < input.length; i++) {
      const c = input[i];
      const type = this.chartype(c);
      if (prevType === null) {
        word = c;
        prevType = type;
      } else if (type === prevType) {
        word += c;
      } else {
        result.push(word);
        word = c;
        prevType = type;
      }
    }
    if (word) result.push(word);
    return result;
  }
}

const segmenter = new TinySegmenter();

const STORAGE_KEY = "textoGuardado";
const tooltip = document.getElementById("tooltip");

// Aquí, para demo, cargamos un texto de ejemplo:
const textoEjemplo = "何より桜祭で馬戦をするのは趣旨が違うと思うのですが";
let anterior = localStorage.getItem(STORAGE_KEY) || "";
if (!anterior) {
  anterior = textoEjemplo;
  localStorage.setItem(STORAGE_KEY, anterior);
}

function crearEnlaceJPDB(word) {
  const a = document.createElement("a");
  a.href = `https://jpdb.io/search?q=${encodeURIComponent(word)}`;
  a.target = "_blank";
  a.rel = "noopener noreferrer";
  a.textContent = word;
  a.style.color = "white";
  a.style.textDecoration = "none";
  a.style.cursor = "pointer";

  a.addEventListener("mouseenter", (e) => {
    // Para simplificar no hacemos fetch de definiciones aquí
    tooltip.textContent = "Ir a jpdb.io para: " + word;
    positionTooltip(e);
    tooltip.classList.add("visible");
  });

  a.addEventListener("mousemove", positionTooltip);

  a.addEventListener("mouseleave", () => {
    tooltip.classList.remove("visible");
  });

  return a;
}

function positionTooltip(event) {
  const padding = 10;
  let x = event.pageX + padding;
  let y = event.pageY + padding;
  const tooltipRect = tooltip.getBoundingClientRect();
  const viewportWidth = window.innerWidth;
  const viewportHeight = window.innerHeight;
  if (x + tooltipRect.width > viewportWidth) {
    x = event.pageX - tooltipRect.width - padding;
  }
  if (y + tooltipRect.height > viewportHeight) {
    y = event.pageY - tooltipRect.height - padding;
  }
  tooltip.style.left = x + "px";
  tooltip.style.top = y + "px";
}

function renderTexto() {
  const contenedor = document.getElementById("textContainer");
  contenedor.innerHTML = "";
  const lineas = (localStorage.getItem(STORAGE_KEY) || "").split("\n").filter(l => l.trim() !== "");

  lineas.forEach((linea) => {
    const div = document.createElement("div");
    div.className = "line";

    const fragment = document.createDocumentFragment();

    // Segmentar la línea palabra a palabra usando TinySegmenter
    const palabras = segmenter.segment(linea);

    palabras.forEach(palabra => {
      // Solo crear enlace si contiene japonés (kanji, kana)
      if (/[\p{Script=Hiragana}\p{Script=Katakana}\p{Script=Han}]/u.test(palabra)) {
        fragment.appendChild(crearEnlaceJPDB(palabra));
      } else {
        fragment.appendChild(document.createTextNode(palabra));
      }
    });

    div.appendChild(fragment);
    contenedor.appendChild(div);
  });
}

renderTexto();

</script>
</body>
</html>
